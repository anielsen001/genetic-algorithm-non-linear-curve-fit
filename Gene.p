unit Gene;interface	type		bit = 0..1;		gene = array[0..47] of bit;	const		pi = 3.1415962;{could come in handy}		numGenes = 500;{must be an even number}	procedure Mate;	procedure MakeTestGene (var one: gene);	procedure Tournament;	procedure Translate (one: gene; var A, Beta, Sigma, Omega: real);	procedure MakeFitness;	function CalcGeneFitness (one: gene): real;	function pwr (base: real; exponent: integer): real;	function ChiSquare (A, Beta, Sigma, Omega: real): real;	function DampedOscil (A, Beta, Sigma, Omega, T: real): real;	function Randomize (range: integer): integer;	procedure MateTwo (var child1, child2: gene; parent1, parent2: gene);	procedure WriteGeneln (one: gene);	function MakeGeneFitness (one: gene): real;	procedure DumpGenes;implementation	function Randomize (range: integer): integer;{returns a random integer between 0 and range}		var			result: longint;	begin{    randseed := tickcount;}{writeln(randseed);}{    randseed := abs(random);}{    randseed := abs(random);}		result := random;		result := abs(result);		randomize := round(result * range / maxint);	end;	procedure DumpGenes;		var			genes: file of gene;			loop: integer;			one: gene;	begin		open(genes, 'genes.dat');		reset(genes);		while not eof(genes) do			begin				read(genes, one);				writegeneln(one);			end;		close(genes);	end;	procedure WriteGeneln (one: gene);{****CORRECT****}		var			loop: integer;	begin		showtext;		for loop := 0 to 46 do			write(one[loop] : 1);		writeln(one[47] : 1);	end;	procedure separate (a: real; var mantissa: real; var exponent: integer);	begin		exponent := 0;		if a >= 1 then			begin				repeat					a := a / 10;					exponent := exponent + 1;				until a <= 1;				mantissa := a;			end		else			begin				repeat					a := a * 10;					exponent := exponent - 1;				until a >= 1;				mantissa := a;			end;	end;	procedure MakeGenePart (baseIndex: integer; mantissa: real; exponent: integer; var one: gene);		var			loop: integer;			plus: boolean;	begin		plus := (mantissa >= 0);		if plus then			one[baseindex] := 1		else			one[baseindex] := 0;		mantissa := abs(mantissa);		mantissa := trunc(mantissa * 65535);		for loop := (baseIndex + 16) downto (baseIndex) do			begin				if mantissa - pwr(2, loop - baseindex - 1) >= 0 then					one[loop] := 1				else					one[loop] := 0;				mantissa := mantissa - pwr(2, loop - baseindex - 1);			end;		plus := (exponent >= 0);		if plus then			one[baseIndex + 18] := 1		else			one[baseIndex + 18] := 0;		exponent := abs(exponent);		for loop := (baseIndex + 21) downto (baseIndex + 18) do			begin				if exponent - pwr(2, loop - baseindex - 1) >= 0 then					one[loop] := 1				else					one[loop] := 0;				exponent := exponent - trunc(pwr(2, loop - baseindex - 1));			end;	end;	procedure maketestgene (var one: gene);		var			a, beta, sigma, omega: real;			exponent: integer;			mantissa: real;	begin		showtext;		write('enter A: ');		readln(a);		separate(a, mantissa, exponent);		MakeGenePart(0, mantissa, exponent, one);		write('enter Beta: ');		readln(beta);		separate(beta, mantissa, exponent);		MakeGenePart(21, mantissa, exponent, one);		write('enter Sigma: ');		readln(sigma);		separate(sigma, mantissa, exponent);		makegenepart(42, mantissa, exponent, one);		write('enter Omega: ');		readln(Omega);		separate(omega, mantissa, exponent);		makegenepart(63, mantissa, exponent, one);	end;	function DampedOscil (A, Beta, Sigma, Omega, T: real): real;{****CORRECT****}	begin		DampedOscil := A * exp(-Beta * t) * cos(Omega * t + sigma);	end;	function ChiSquare (A, Beta, Sigma, Omega: real): real;		var			Data: file of real;			loop: integer;			hvalue, tvalue, deviation: real;			ChiSquared: real;	begin		open(Data, 'Data.dat');		reset(data);		ChiSquared := 0;		while not eof(Data) do			begin				read(Data, hvalue, tvalue, deviation);{writeln(hvalue, tvalue);}				ChiSquared := ChiSquared + 1 / Sqr(deviation) * Sqr(hvalue - DampedOscil(A, Beta, Sigma, Omega, tvalue));			end;		chisquare := chisquared;		close(data);	end;	function pwr (base: real; exponent: integer): real;{*****CORRECT*****}{raises the base to the exponent}	begin		pwr := exp(exponent * ln(base));	end;	procedure Translate (one: gene; var A, Beta, Sigma, Omega: real);{*****CORRECT*****}{Translates the gene into its corresponding numerical values}		var			loop1, loop: integer;			PlusMantissa, PlusExponent: boolean;			power10: integer;			Mantissa, Exponent: real;	begin		for loop1 := 0 to 3 do			begin				mantissa := 0;				exponent := 0;				if one[(loop1 * 12)] = 1 then					PlusMantissa := true				else					PlusMantissa := false;				for Loop := 1 to 8 do					if one[loop + (loop1 * 12)] = 1 then						Mantissa := mantissa + pwr(2, (loop - 1))					else						Mantissa := Mantissa;				Mantissa := Mantissa / 256.0;				if not PlusMantissa then					Mantissa := -Mantissa;				if one[9 + (Loop1 * 12)] = 1 then					PlusExponent := true				else					PlusExponent := false;				for loop := 10 to 11 do					if one[loop + (loop1 * 12)] = 1 then						Exponent := Exponent + pwr(2, (loop - 12))					else						Exponent := Exponent;				if not PlusExponent then					Exponent := -Exponent;				power10 := trunc(Exponent);				case loop1 of					0: 						A := Mantissa * pwr(10, power10);					1: 						Beta := Mantissa * pwr(10, power10);					2: 						Sigma := mantissa * pwr(10, power10);					3: 						Omega := Mantissa * pwr(10, power10);				end;			end;	end;	function MakeGeneFitness (one: gene): real;{Calculates the fitness of an individual gene based on the value of Chi Squared which it produces}		var			A, Beta, Sigma, Omega: real;			Fitness: real;	begin		Translate(one, A, Beta, Sigma, Omega);		Fitness := ChiSquare(A, Beta, Sigma, Omega);		MakeGeneFitness := Fitness;	end;	procedure MakeFitness;{Calculates the fitness of the entire gene pool}		var			Genes: file of gene;			One: gene;			Fitness: file of real;			Fit: real;{the fitness of the gene}			A, Beta, Sigma, Omega: real;			loop: integer;	begin		open(Genes, 'Genes.dat');		reset(Genes);		open(Fitness, 'Fitness.dat');		rewrite(Fitness);		A := 0;		Beta := 0;		Sigma := 0;		Omega := 0;		while not eof(Genes) do			begin				read(Genes, one);				Translate(one, A, Beta, Sigma, Omega);				fit := ChiSquare(A, Beta, Sigma, Omega);				write(Fitness, fit);			end;		close(fitness);		close(Genes);	end;	procedure Tournament;{runs the tournament selection algorithm}{randomly selects two individuals from the population.  The individual with the highest fitness}{(lowest Chi Square value) prevails and is allowed to mate with the other winners of the tournament}		var			Genes: file of gene;			NewGenes: file of gene;			First, Second: gene;			FitOne, FitTwo: real;			Fitness: file of real;			NewFitness: file of real;			GeneIndex: integer;			loop: integer;			Halfgenes: integer;	begin		open(NewFitness, 'NewFitness.dat');		rewrite(newfitness);		open(newgenes, 'NewGenes.dat');		rewrite(NewGenes);		open(Genes, 'Genes.dat');{reset(Genes);}		open(Fitness, 'Fitness.dat');		halfgenes := numGenes div 2;		for loop := 1 to HalfGenes do			begin				GeneIndex := randomize(numGenes - 1);				seek(Genes, GeneIndex);				read(genes, First);				seek(Fitness, GeneIndex);				read(Fitness, Fitone);				GeneIndex := randomize(numgenes - 1);				seek(Genes, Geneindex);				read(genes, second);				seek(Fitness, geneIndex);				read(Fitness, fittwo);				if fitOne < FitTwo then					begin						write(NewGenes, First);						write(newfitness, fitone);					end				else					begin						write(NewGenes, Second);						write(newfitness, fittwo);					end;			end;		close(NewGenes);		close(newFitness);		close(Genes);		close(fitness);	end;	procedure MateTwo (var child1, child2: gene; parent1, parent2: gene);{****CORRECT****}		var			loop1, loop2: integer;			crosspoint: integer;	begin		CrossPoint := randomize(46);		for loop1 := 0 to CrossPoint do			begin				child1[loop1] := parent1[loop1];				if randomize(100) > 75 then                              {random mutation}					if child1[loop1] = 0 then						child1[loop1] := 1					else						child1[loop1] := 0;				child2[loop1] := parent2[loop1];				if randomize(100) > 75 then                           {random mutation}					if child2[loop1] = 0 then						child2[loop1] := 1					else						child2[loop1] := 0;			end;		for loop2 := (CrossPoint + 1) to 47 do			begin				child1[loop2] := parent2[loop2];				if randomize(100) > 75 then                            {performs random mutations 75% of the time}					if child1[loop1] = 0 then						child1[loop1] := 1					else						child1[loop1] := 0;				child2[loop2] := parent1[loop2];				if randomize(100) > 75 then                           {performs the mutation}					if child2[loop1] = 0 then						child2[loop1] := 1					else						child2[loop1] := 0;			end;	end;	procedure Mate;{randomly selects two parent genes from the winners of the tournament.  the two parents are mated by}{choosing a random number along the length of the string and then swapping parts of the string at the}{crosspoint}		var			SelectedGenes: file of gene;{NewGenes: file of gene;}			Fitness: file of real;			NewFitness: file of real;			Genes: file of gene;			halfGenes: integer;			Mother, Father: gene;			son, daughter: gene;			MateIndex1, MateIndex2: integer;			loop, loop1, loop2: integer;			FatherFit, MotherFit, SonFit, DaughterFit: real;			avgfitness: real;	begin		halfGenes := numGenes div 2;		open(NewFitness, 'NewFitness.dat');		open(SelectedGenes, 'NewGenes.dat');		open(Fitness, 'Fitness.dat');		rewrite(Fitness);		open(Genes, 'Genes.dat');		rewrite(Genes);		avgfitness := 0;		for loop := 1 to halfgenes do			begin				MateIndex1 := randomize(halfgenes - 1);                {randomly selects two genes to mate from the tournament population}				mateIndex2 := randomize(halfgenes - 1);				seek(SelectedGenes, mateIndex1);				read(SelectedGenes, Father);				seek(NewFitness, mateIndex1);				read(NewFitness, Fatherfit);				seek(SelectedGenes, mateIndex2);				read(SelectedGenes, Mother);				seek(NewFitness, mateindex2);				read(NewFitness, Motherfit);				MateTwo(son, daughter, father, mother);				write(Genes, Father);				write(Genes, Mother);				write(Genes, Son);				write(Genes, Daughter);				write(Fitness, Fatherfit);				write(fitness, Motherfit);				SonFit := MakeGeneFitness(Son);				DaughterFit := MakeGeneFitness(Daughter);				write(Fitness, sonfit);				write(Fitness, Daughterfit);{writeln(fatherfit, motherfit, sonfit, daughterfit);}{    avgfitness := avgfitness + fatherfit + motherfit + sonfit + daughterfit;}			end;{    avgfitness := avgfitness / numgenes;}{    writeln('average gene fitness: ', avgfitness : 10 : 10);}		close(Genes);		close(Fitness);		Close(SelectedGenes);		Close(NewFitness);{    Close(newGenes);}	end;end.